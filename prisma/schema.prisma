// EDH Builder - Prisma Schema
// MTG Commander Deck Builder Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// NextAuth.js Required Models
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  password      String?   // Hashed password for email/password auth (null for OAuth users)

  // User profile data
  username String? @unique
  bio      String?

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  accounts  Account[]
  sessions  Session[]
  decks     Deck[]
  favorites FavoriteDeck[]

  // Social relations
  followers             Follow[]           @relation("Following") // Users who follow this user
  following             Follow[]           @relation("Followers") // Users this user follows
  reviews               DeckReview[]
  collaborations        DeckCollaborator[]
  conversationsAsUser1  Conversation[]     @relation("ConversationsAsUser1")
  conversationsAsUser2  Conversation[]     @relation("ConversationsAsUser2")
  messages              Message[]
  notifications         Notification[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// MTG Card Models
// ============================================

model Card {
  id         String  @id @default(cuid())
  scryfallId String  @unique @map("scryfall_id")
  oracleId   String? @map("oracle_id")

  // Card identity
  name       String
  manaCost   String? @map("mana_cost")
  cmc        Float   @default(0) // Converted mana cost
  typeLine   String  @map("type_line")
  oracleText String? @map("oracle_text") @db.Text

  // Colors and identity (stored as comma-separated string: "W,U,B,R,G")
  colors        String? // Card colors
  colorIdentity String? @map("color_identity") // Commander color identity

  // Card characteristics
  power     String?
  toughness String?
  loyalty   String?

  // Legality
  isLegalCommander Boolean @default(false) @map("is_legal_commander")

  // Images (JSON object with different sizes)
  imageUris Json? @map("image_uris")

  // Pricing (optional, for reference)
  priceUsd Decimal? @map("price_usd") @db.Decimal(10, 2)
  priceTix Decimal? @map("price_tix") @db.Decimal(10, 2)

  // Metadata
  setCode String     @map("set_code")
  setName String     @map("set_name")
  rarity  CardRarity

  // Caching metadata
  cachedAt      DateTime  @default(now()) @map("cached_at")
  imageCachedAt DateTime? @map("image_cached_at")

  // Cached image URLs (Cloudflare R2)
  cachedImageSmall  String? @map("cached_image_small")
  cachedImageNormal String? @map("cached_image_normal")
  cachedImageLarge  String? @map("cached_image_large")

  // Double-faced card support
  hasBackFace           Boolean @default(false) @map("has_back_face")
  backFaceImageUris     Json?   @map("back_face_image_uris")
  cachedBackImageSmall  String? @map("cached_back_image_small")
  cachedBackImageNormal String? @map("cached_back_image_normal")
  cachedBackImageLarge  String? @map("cached_back_image_large")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  deckCards   DeckCard[]
  commanderOf Deck[]     @relation("Commander")
  partnerOf   Deck[]     @relation("Partner")

  @@index([name])
  @@index([scryfallId])
  @@index([isLegalCommander])
  @@index([cachedAt])
  @@map("cards")
}

// ============================================
// Deck Models
// ============================================

model Deck {
  id          String  @id @default(cuid())
  name        String
  description String? @db.Text

  // Deck format and status
  format     DeckFormat @default(COMMANDER)
  isPublic   Boolean    @default(false) @map("is_public")
  isComplete Boolean    @default(false) @map("is_complete") // Has 100 cards

  // Commander reference
  commanderId String? @map("commander_id")
  commander   Card?   @relation("Commander", fields: [commanderId], references: [id])

  // Partner commander (optional)
  partnerId String? @map("partner_id")
  partner   Card?   @relation("Partner", fields: [partnerId], references: [id])

  // Owner
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Deck statistics (computed/cached)
  cardCount     Int      @default(0) @map("card_count")
  avgCmc        Float?   @map("avg_cmc")
  colorIdentity String[] @map("color_identity") // ['W', 'U', 'B', 'R', 'G']

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  cards         DeckCard[]
  favorites     FavoriteDeck[]
  tags          DeckTag[]
  reviews       DeckReview[]
  collaborators DeckCollaborator[]

  @@index([userId])
  @@index([isPublic])
  @@index([commanderId])
  @@map("decks")
}

model DeckCard {
  id       String @id @default(cuid())
  quantity Int    @default(1)

  // Category within deck
  category CardCategory @default(MAIN)

  // Relations
  deckId String @map("deck_id")
  deck   Deck   @relation(fields: [deckId], references: [id], onDelete: Cascade)

  cardId String @map("card_id")
  card   Card   @relation(fields: [cardId], references: [id])

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([deckId, cardId])
  @@map("deck_cards")
}

model FavoriteDeck {
  id String @id @default(cuid())

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  deckId String @map("deck_id")
  deck   Deck   @relation(fields: [deckId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([userId, deckId])
  @@map("favorite_decks")
}

model Tag {
  id   String @id @default(cuid())
  name String @unique
  slug String @unique

  decks DeckTag[]

  @@map("tags")
}

model DeckTag {
  id String @id @default(cuid())

  deckId String @map("deck_id")
  deck   Deck   @relation(fields: [deckId], references: [id], onDelete: Cascade)

  tagId String @map("tag_id")
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([deckId, tagId])
  @@map("deck_tags")
}

// ============================================
// Enums
// ============================================

enum CardRarity {
  common
  uncommon
  rare
  mythic
  special
  bonus
}

enum DeckFormat {
  COMMANDER
  BRAWL
  OATHBREAKER
}

enum CardCategory {
  MAIN       // Main deck
  COMMANDER  // Commander zone
  SIDEBOARD  // Sideboard/Maybeboard
  CONSIDERING // Cards being considered
}

enum CollaboratorRole {
  VIEWER // Can view private deck
  EDITOR // Can add/remove cards
  ADMIN  // Can manage collaborators
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum NotificationType {
  DECK_LIKE            // Someone liked your deck
  DECK_REVIEW          // Someone reviewed your deck
  COLLABORATION_INVITE // Invited to collaborate on a deck
  COLLABORATION_ACCEPTED // Someone accepted your invite
  NEW_FOLLOWER         // Someone followed you
  NEW_MESSAGE          // New direct message
}

// ============================================
// Social Features Models
// ============================================

model Follow {
  id          String   @id @default(cuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  follower  User @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model DeckReview {
  id        String   @id @default(cuid())
  deckId    String   @map("deck_id")
  userId    String   @map("user_id")
  rating    Int      // 1-5 stars
  title     String?
  content   String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  deck Deck @relation(fields: [deckId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([deckId, userId]) // One review per user per deck
  @@index([deckId])
  @@index([userId])
  @@map("deck_reviews")
}

model DeckCollaborator {
  id        String           @id @default(cuid())
  deckId    String           @map("deck_id")
  userId    String           @map("user_id")
  role      CollaboratorRole @default(VIEWER)
  status    InviteStatus     @default(PENDING)
  invitedAt DateTime         @default(now()) @map("invited_at")
  joinedAt  DateTime?        @map("joined_at")

  deck Deck @relation(fields: [deckId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([deckId, userId])
  @@index([deckId])
  @@index([userId])
  @@index([status])
  @@map("deck_collaborators")
}

model Conversation {
  id            String   @id @default(cuid())
  participant1  String   @map("participant_1")
  participant2  String   @map("participant_2")
  lastMessageAt DateTime @default(now()) @map("last_message_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user1    User      @relation("ConversationsAsUser1", fields: [participant1], references: [id], onDelete: Cascade)
  user2    User      @relation("ConversationsAsUser2", fields: [participant2], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([participant1, participant2])
  @@index([participant1])
  @@index([participant2])
  @@index([lastMessageAt])
  @@map("conversations")
}

model Message {
  id             String    @id @default(cuid())
  conversationId String    @map("conversation_id")
  senderId       String    @map("sender_id")
  content        String    @db.Text
  readAt         DateTime? @map("read_at")
  createdAt      DateTime  @default(now()) @map("created_at")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@map("messages")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String?
  data      Json?            // Flexible payload for links, references
  readAt    DateTime?        @map("read_at")
  createdAt DateTime         @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([userId, createdAt])
  @@map("notifications")
}
